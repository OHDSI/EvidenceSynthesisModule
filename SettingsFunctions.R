# This file has been autogenerated in 'extras/ModuleMaintenance.R'. Do not change by hand.
# Copyright 2022 Observational Health Data Sciences and Informatics
#
# This file is part of EvidenceSynthesisModule
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Create an evidence synthesis source
#'
#' @param sourceMethod            The source method generating the estimates to synthesize. Can be "CohortMethod" or
#'                                "SelfControlledCaseSeries"
#' @param databaseIds             The database  IDs to include. Use `databaseIds = NULL` to include all database IDs.
#' @param analysisIds             The source method analysis IDs to include. Use `analysisIds = NULL` to include all
#'                                analysis IDs.
#' @param likelihoodApproximation The type of likelihood approximation. Can be "adaptive grid" or "normal".
#'
#' @return
#' An object of type `EvidenceSynthesisSource`.
#'
#' @export
createEvidenceSynthesisSource <- function(sourceMethod = "CohortMethod",
                                          databaseIds = NULL,
                                          analysisIds = NULL,
                                          likelihoodApproximation = "adaptive grid") {
  errorMessages <- checkmate::makeAssertCollection()
  checkmate::assertChoice(sourceMethod, c("CohortMethod", "SelfControlledCaseSeries"), add = errorMessages)
  if (is.character(databaseIds)) {
    checkmate::assertCharacter(databaseIds, null.ok = TRUE, add = errorMessages)
  } else {
    checkmate::assertIntegerish(databaseIds, null.ok = TRUE, add = errorMessages)
  }
  checkmate::assertIntegerish(analysisIds, null.ok = TRUE, add = errorMessages)
  checkmate::assertChoice(likelihoodApproximation, c("adaptive grid", "normal"), add = errorMessages)
  checkmate::reportAssertions(collection = errorMessages)

  analysis <- list()
  for (name in names(formals(createEvidenceSynthesisSource))) {
    analysis[[name]] <- get(name)
  }
  class(analysis) <- "EvidenceSynthesisSource"
  return(analysis)
}

#' Create specifications for the EvidenceSynthesisModule
#'
#' @param evidenceSynthesisAnalysisList A list of objects of type `EvidenceSynthesisAnalysis`` as generated
#'                                      by either the [createFixedEffectsMetaAnalysis()] or
#'                                      [createBayesianMetaAnalysis()] function.
#' @param esDiagnosticThresholds.       An object of type`EsDiagnosticThresholds` as generated by the
#'                                      [createEsDiagnosticThresholds()] function.
#'
#' @return
#' An object of type `EvidenceSynthesisModuleSpecifications`.
#'
#' @export
createEvidenceSynthesisModuleSpecifications <- function(evidenceSynthesisAnalysisList,
                                                        esDiagnosticThresholds = createEsDiagnosticThresholds()) {
  errorMessages <- checkmate::makeAssertCollection()
  checkmate::assertList(evidenceSynthesisAnalysisList, min.len = 1, add = errorMessages)
  for (i in 1:length(evidenceSynthesisAnalysisList)) {
    checkmate::assertClass(evidenceSynthesisAnalysisList[[i]], "EvidenceSynthesisAnalysis", add = errorMessages)
  }
  checkmate::assertClass(esDiagnosticThresholds, "EsDiagnosticThresholds", add = errorMessages)
  checkmate::reportAssertions(collection = errorMessages)
  specifications <- list(settings = list(evidenceSynthesisAnalysisList = evidenceSynthesisAnalysisList,
                                         esDiagnosticThresholds = esDiagnosticThresholds),
                         module = "EvidenceSynthesisModule",
                         version = "0.5.0",
                         remoteRepo = "github.com",
                         remoteUsername = "ohdsi")
  class(specifications) <- c("EvidenceSynthesisModuleSpecifications", "ModuleSpecifications")
  return(specifications)
}

#' Create parameters for a random-effects meta-analysis
#'
#' @details
#' Use DerSimonian-Laird meta-analysis
#'
#' @param alpha  The alpha (expected type I error) used for the confidence intervals.
#' @param evidenceSynthesisAnalysisId
#' @param evidenceSynthesisSource
#' @param controlType
#'
#' @export
createRandomEffectsMetaAnalysis <- function(alpha = 0.05,
                                            evidenceSynthesisAnalysisId = 1,
                                            evidenceSynthesisDescription = "Random-effects",
                                            evidenceSynthesisSource = NULL,
                                            controlType = "outcome") {
  if (evidenceSynthesisSource$likelihoodApproximation != "normal") {
    stop("Random-effects meta-analysis only supports normal approximation of the likelihood.")
  }
  analysis <- list()
  for (name in names(formals(createFixedEffectsMetaAnalysis))) {
    analysis[[name]] <- get(name)
  }
  class(analysis) <- c("RandomEffectsMetaAnalysis", "EvidenceSynthesisAnalysis")
  return(analysis)
}


#' Create a parameter object for the function computeFixedEffectMetaAnalysis
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param alpha  The alpha (expected type I error) used for the confidence intervals.
#' @param evidenceSynthesisAnalysisId
#' @param evidenceSynthesisDescription
#' @param evidenceSynthesisSource
#' @param controlType
#'
#' @export
createFixedEffectsMetaAnalysis <- function(alpha = 0.05,
                                           evidenceSynthesisAnalysisId = 1,
                                           evidenceSynthesisDescription = "Fixed-effects",
                                           evidenceSynthesisSource = NULL,
                                           controlType = "outcome") {
  analysis <- list()
  for (name in names(formals(createFixedEffectsMetaAnalysis))) {
    analysis[[name]] <- get(name)
  }
  class(analysis) <- c("FixedEffectsMetaAnalysis", "EvidenceSynthesisAnalysis")
  if (evidenceSynthesisSource$likelihoodApproximation != "normal")
                stop("Fixed-effects meta-analysis only supports normal approximation of the likelihood.")
  return(analysis)
}

#' Create a parameter object for the function computeBayesianMetaAnalysis
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param chainLength  Number of MCMC iterations.
#' @param burnIn  Number of MCMC iterations to consider as burn in.
#' @param subSampleFrequency  Subsample frequency for the MCMC.
#' @param priorSd  A two-dimensional vector with the standard deviation of the prior for mu and tau, respectively.
#' @param alpha  The alpha (expected type I error) used for the credible intervals.
#' @param robust  Whether or not to use a t-distribution model; default: FALSE.
#' @param df  Degrees of freedom for the t-model, only used if robust is TRUE.
#' @param seed  The seed for the random number generator.
#' @param evidenceSynthesisAnalysisId
#' @param evidenceSynthesisDescription
#' @param evidenceSynthesisSource
#' @param controlType
#'
#' @export
createBayesianMetaAnalysis <- function(chainLength = 1100000,
                                       burnIn = 1e+05,
                                       subSampleFrequency = 100,
                                       priorSd = c(2, 0.5),
                                       alpha = 0.05,
                                       robust = FALSE,
                                       df = 4,
                                       seed = 1,
                                       evidenceSynthesisAnalysisId = 1,
                                       evidenceSynthesisDescription = "Bayesian random-effects",
                                       evidenceSynthesisSource = NULL,
                                       controlType = "outcome") {
  analysis <- list()
  for (name in names(formals(createBayesianMetaAnalysis))) {
    analysis[[name]] <- get(name)
  }
  class(analysis) <- c("BayesianMetaAnalysis", "EvidenceSynthesisAnalysis")
  return(analysis)
}

#' Create EvidenceSynthesis diagnostics thresholds
#'
#' @description
#' Threshold used to determine if we pass or fail diagnostics.
#'
#' @param mdrrThreshold         What is the maximum allowed minimum detectable relative risk
#'                              (MDRR)?
#' @param easeThreshold         What is the maximum allowed expected absolute systematic error
#'                              (EASE).
#' @param i2Threshold           What is the maximum allowed I^2 (measure of between-database
#'                              heterogeneity in random-effects models)?
#' @param tauThreshold          What is the maximum allowed tau (measure of between-database
#'                              heterogeneity in Bayesian random-effects models)?
#'
#' @return
#' An object of type `EsDiagnosticThresholds`.
#'
#' @export
createEsDiagnosticThresholds <- function(mdrrThreshold = 10,
                                         easeThreshold = 0.25,
                                         i2Threshold = 0.4,
                                         tauThreshold = log(2)) {
  errorMessages <- checkmate::makeAssertCollection()
  checkmate::assertNumeric(mdrrThreshold, len = 1, lower = 0, add = errorMessages)
  checkmate::assertNumeric(easeThreshold, len = 1, lower = 0, add = errorMessages)
  checkmate::assertNumeric(i2Threshold, len = 1, lower = 0, add = errorMessages)
  checkmate::assertNumeric(tauThreshold, len = 1, lower = 0, add = errorMessages)
  checkmate::reportAssertions(collection = errorMessages)
  thresholds <- list(
    mdrrThreshold = mdrrThreshold,
    easeThreshold = easeThreshold,
    i2Threshold = i2Threshold,
    tauThreshold = tauThreshold
  )
  class(thresholds) <- "EsDiagnosticThresholds"
  return(thresholds)
}
